Berikut ini schema dan controller untuk service delivery


// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model Delivery {
  id              String           @id @default(auto()) @map("_id") @db.ObjectId
  deliveryId      String           @unique 
  deliveryDate    DateTime         @default(now())
  receivedDate    DateTime?       
  status          DeliveryStatus
  driver          String      
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  deletedAt       DateTime?
  details         DeliveryDetail[]  @relation("DeliveryDetails")          
  
  @@map("delivery")
}

model DeliveryDetail {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  deliveryId  String   // foreign-like reference to Delivery
  productId   String
  quantity    Int
  notes       String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime? 
  delivery    Delivery @relation("DeliveryDetails", fields: [deliveryId], references: [id])  
  @@map("delivery_detail")
}

enum DeliveryStatus {
  PENDING
  IN_PROGRESS
  DELIVERED
  CANCELLED
}


const {PrismaClient} = require('@prisma/client')

const prisma = new PrismaClient();

const findAllDelivery = async (req, res) => {
    try{
        const delivery = await prisma.Delivery.findMany({
            select : {
                id : true,
                deliveryId : true,
                deliveryDate : true,
                receivedDate : true,
                status : true,
                createdAt : true,
                updatedAt : true,
            }
        });

        res.status(200).send({
            success: true,
            message: "Successfully Find All Delivery Records",
            data: delivery,
        });
    }catch(error){
        console.log(error)
        res.status(500).send({
            success: false,
            message: "Internal Server Error",
        })
    }
};

const createDelivery = async (req, res) => {  
    try {  
        const { products, sender } = req.body; // Mengambil informasi produk dan pengirim dari request body  
  
        // Validasi input  
        if (!products || !sender) {  
            return res.status(400).json({ message: 'Informasi produk dan pengirim harus disediakan.' });  
        }  
  
        // Membuat entri pengiriman  
        const delivery = await prisma.delivery.create({  
            data: {  
                deliveryId: generateUniqueDeliveryId(), // Menggunakan helper untuk ID unik  
                status: 'IN_PROGRESS',  
                driver: sender.driver, // Menyimpan informasi driver  
                details: {  
                    create: products.map(product => ({  
                        productId: product.productId,  
                        quantity: product.quantity,  
                        notes: product.notes,  
                    })),  
                },  
            },  
            include: {  
                details: true, 
            },  
        });  
  
        // Menghasilkan response  
        return res.status(201).json({  
            delivery: {  
                id: delivery.id,  
                deliveryId: delivery.deliveryId,  
                deliveryDate: delivery.deliveryDate,  
                status: delivery.status,  
                driver: delivery.driver,  
                details: delivery.details,  
            },  
            sender: sender,  
        });  
    } catch (error) {  
        console.error(error);  
        return res.status(500).json({ message: 'Terjadi kesalahan saat membuat pengiriman.' });  
    } finally {  
        await prisma.$disconnect(); // Menutup koneksi Prisma  
    }  
};


const updateDeliveryStatus = async (req, res) => {  
    try {  
        const { deliveryId } = req.params; 
        const { status } = req.body; 
        
        if (!status) {  
            return res.status(400).json({ message: 'Status tidak tersedia' });  
        }  

        const newStatus = status ? 'DELIVERED' : 'CANCELED';  
        const receivedDate = status ? new Date() : null; 

        const updatedDelivery = await prisma.delivery.update({  
            where: { deliveryId: deliveryId },
            data: {  
                status: newStatus,  
                receivedDate: receivedDate,  
            },  
        });   
  
         return res.status(200).json({  
            message: 'Status pengiriman berhasil diupdate.',  
            delivery: updatedDelivery,  
        });  
    } catch (error) {  
        console.error(error);  
        return res.status(500).json({ message: 'Terjadi kesalahan saat mengupdate status pengiriman.' });  
    } finally {  
        await prisma.$disconnect();   
    }  
};  

const generateUniqueDeliveryId = () => {  
    const prefix = 'bakinv'; // Prefix tetap  
    const timestamp = Date.now(); // Menggunakan timestamp sebagai bagian dari ID  
    const uniqueId = `${prefix}${timestamp}`; // Menggabungkan prefix dengan timestamp  
    return uniqueId;  
};  


module.exports = {
    findAllDelivery,
    createDelivery,
    updateDeliveryStatus
}


dari controller dan schema tersebut buatkan resolver dan schemanya mengikuti referensi di bawah ini 

const { PrismaClient } = require('@prisma/client');    
const prisma = new PrismaClient();    
  
const resolvers = {    
    // Queries    
    findCategories: async () => {    
        return await prisma.category.findMany();    
    },    
    findCategoryById: async ({ id }) => {    
        return await prisma.category.findUnique({    
            where: { id: id },    
            include: { materials: true },    
        });    
    },    
    findMaterials: async () => {    
        return await prisma.material.findMany({    
            include: {    
                category: true,    
                materialDetails: true,    
            },    
        });    
    },    
    findMaterialById: async ({ id }) => {    
        return await prisma.material.findUnique({    
            where: { id: id },    
            include: {    
                category: true,    
                materialDetails: true,    
            },    
        });    
    },    
    getMaterialLogs: async ({ status }) => {    
        return await prisma.materialLog.findMany({    
            where: status ? { status: status } : {},    
            orderBy: {    
                createdAt: 'desc',    
            },    
        });    
    },    
  
    // Mutations    
    createCategory: async ({ name, description }) => {    
        return await prisma.category.create({    
            data: {    
                name,    
                description,    
            },    
        });    
    },    
    updateCategory: async ({ id, name, description }) => {    
        return await prisma.category.update({    
            where: { id: id },    
            data: {    
                name,    
                description,    
            },    
        });    
    },    
    deleteCategory: async ({ id }) => {    
        await prisma.category.delete({ where: { id: id } });    
        return "Category deleted successfully";    
    },    
    createMaterial: async ({ name, description, categoryId, details }) => {    
        return await prisma.material.create({    
            data: {    
                name,    
                description,    
                category: { connect: { id: categoryId } },    
                materialDetails: {    
                    create: details.map(detail => ({    
                        batchNumber: detail.batchNumber,    
                        quantity: detail.quantity,    
                        expiredAt: detail.expiredAt ? new Date(detail.expiredAt) : null,    
                    })),    
                },    
            },    
            include: {    
                category: true,    
                materialDetails: true,    
            },    
        });    
    },    
    updateMaterial: async ({ id, name, description, categoryId, details }) => {    
        const material = await prisma.material.findUnique({ where: { id: id } });    
  
        if (!material) {    
            throw new Error("Material not found");    
        }    
  
        const updateData = {};    
        if (name) updateData.name = name;    
        if (description) updateData.description = description;    
        if (categoryId) updateData.categoryId = categoryId;    
  
        const updatedMaterial = await prisma.material.update({    
            where: { id: id },    
            data: updateData,    
            include: {    
                category: true,    
                materialDetails: true,    
            },    
        });    
  
        if (details) {    
            await prisma.materialDetail.deleteMany({ where: { materialId: id } });    
            await prisma.materialDetail.createMany({    
                data: details.map(detail => ({    
                    batchNumber: detail.batchNumber,    
                    quantity: detail.quantity,    
                    expiredAt: detail.expiredAt ? new Date(detail.expiredAt) : null,    
                    materialId: id,    
                })),    
            });    
        }    
  
        return updatedMaterial;    
    },    
    deleteMaterial: async ({ id }) => {    
        await prisma.material.delete({ where: { id: id } });    
        return "Material deleted successfully";    
    },    
    requestStock: async ({ materialId, requestedQuantity }) => {    
        // Implementation of stock request logic here    
        return "Stock request processed";    
    },    
};    
  
module.exports = resolvers;  


const { buildSchema } = require('graphql');  
  
const schema = buildSchema(`  
  
type Category {    
    id: ID!    
    name: String!    
    description: String    
    createdAt: String!    
    updatedAt: String    
}    
  
type MaterialDetail {    
    id: ID!    
    batchNumber: String    
    quantity: Int!    
    expiredAt: String    
    materialId: ID!    
}    
  
type Material {    
    id: ID!    
    name: String!    
    description: String    
    categoryId: ID!    
    category: Category    
    materialDetails: [MaterialDetail]    
    createdAt: String!    
    updatedAt: String    
}    
  
type MaterialLog {    
    id: ID!    
    material_id: ID!    
    quantity: Int!    
    message: String!    
    status: String!    
    createdAt: String!    
}    
  
type Query {    
    findCategories: [Category]    
    findCategoryById(id: ID!): Category    
    findMaterials: [Material]    
    findMaterialById(id: ID!): Material    
    getMaterialLogs(status: String): [MaterialLog]    
}    
  
type Mutation {    
    createCategory(name: String!, description: String): Category    
    updateCategory(id: ID!, name: String!, description: String): Category    
    deleteCategory(id: ID!): String    
    createMaterial(name: String!, description: String, categoryId: ID!, details: [MaterialDetailInput]): Material    
    updateMaterial(id: ID!, name: String, description: String, categoryId: ID, details: [MaterialDetailInput]): Material    
    deleteMaterial(id: ID!): String    
    requestStock(materialId: ID!, requestedQuantity: Int!): String    
}    
  
input MaterialDetailInput {    
    batchNumber: String    
    quantity: Int!    
    expiredAt: String    
}    
`);  
  
module.exports = schema;  